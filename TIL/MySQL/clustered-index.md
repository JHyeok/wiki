# 클러스트링 인덱스

- 클러스트란 여러 개를 하나로 묶는다는 의미로 주로 사용
- MySQL에서 클러스트링 인덱스는 InnoDB와 TokuDB 스토리지 엔진에서만 지원
- 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현
- 프라이머리 키값에 의해 레코드의 저장 위치가 결정
- 프라이머리 키값이 변경되면 그 레코드의 물리적인 저장위치가 바뀌어야 한다는 것을 의미
- 클러스터링 인덱스와 클러스터 테이블은 동의어로 사용
- 클러스터링의 기준이 되는 프라이머리 키는 클러스터 키
- B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장
- 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리됨
- InnoDB 테이블에서 프라이머리 키는 클러스터링 인덱스의 기준이 됨
- 클러스터링 인덱스는 (InnoDB 테이블별로) 단 한번만 가질 수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시하는 것이 좋다.

**MyISAM과 같은 일반 클러스터 되지 않은 일반 프라이머리 키와 클러스터 인덱스를 비교했을 때의 장단점**
- MyISAM은 MySQL 관계형 데이터베이스 관리시스템 5.5 버전 이전의 기본 스토리지 엔진
- MySQL 5.5과 이후 판은 참조 무결성 제한과 더 높은 동시성을 보장하기 위해 InnoDB 엔진으로 전환

**장점**
- 프라이머리 키(클러스터 키)로 검색할 때 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름)
- 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(= 커버링 인덱스)

**단점**
- 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키값의 크기가 클 경우 전체적으로 인덱스 크기 커짐
- 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 조금 느림
- INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

**결론**
- InnoDB에서는 인덱스가 커질 수록 메모리가 더 필요해진다(레코드의 건수가 늘어나면 늘어날수록). 그러므로 InnoDB 테이블의 프라이머리 키는 신중하게 선택을 해야한다.
- 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 컬럼으로 생성할 것(가능한 경우), 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 프라이머리 키로 하는 것이 좋다.
- 프라이머리키는 반드시 명시할 것(InnoDB 테이블에서는 프라이머리 키를 정의하지 않으면 AUTO_INCREMENT와 같은 자동 증가 컬럼을 내부적으로 추가하기 때문에 결국 AUTO_INCREMENT컬럼 생성하고 프라이머리 키 설정하는 것과 같다, 그렇다면 설정하는게 더 좋다)
- 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO_INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움된다.

---
#### 참고

https://ko.wikipedia.org/wiki/MyISAM

https://12bme.tistory.com/149





